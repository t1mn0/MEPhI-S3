## Лабораторная работа №1 по курсу «Информатика (организация и поиск данных)» (3 семестр) 
### Постановка задачи

Реализовать идиому «умный указатель» для обеспечения автоматического управления памятью, показать эффективность полученной реализации (отсутствие утечек) на тестах. 

### Минимальные требования к программе. 
Концепция умных указателей может быть реализована по-разному, но в любом случае реализация должна быть снабжена функциональными и нагрузочными тестами. 
Последние должны показывать затраты по времени и по памяти на обслуживание умных указателей и сравнение с вариантом без них (опционально – еще сравнение с STL реализацией). Пользовательский интерфейс может быть как консольным, так и графическим.

### Результат
В ходе лабораторной работы 1 было создано два типа указателя: `SharedPtr<T>` и `UniquePtr<T, Deleter>`. Последний получил специализацию для `T[]`, а также отдельную функцию `MakeUnique`. Анализ эффективности проводился на основе реализации `UniquePtr<T>`, `std::unique_ptr<T>`, классических указателей. Графики представлены ниже:
![DependencyGraph](img/L1%20DependencyGraph.png)
Нагрузочное тестирование заключалось в 100 замерах времени по созданию 1000 объектов одного типа и значения. Левый график показывает, сколько времени уходило на создание объектов под `unique_ptr<string>` реализации STL (через `make_unique`). Правый график аналогичен, только объекты `string` создавались под собственную реализацию `UniquePtr<T>` через `MakeUnique`. Центральный график демонстрирует создание классических (_rawptr_) указателей на объекты `string`.

### Simple console UI via ncurses
>![UI](img/GUI%20L1.gif)



## Лабораторная работа №3 по курсу «Информатика (организация и поиск данных)» (3 семестр)
### Постановка задачи
Выбрать задачу из списка и решить ее, применяя необходимые структуры и алгоритмы (алгоритмы + структуры = программы).
    Написать программу на _C++_ для сравнения различных алгоритмов поиска. Сравнение алгоритмов должно производиться на одной из приведенных задач, связанных с обработкой информации. Выполнить реализацию соответствующих структур данных для решения выбранной задачи.

### Минимальные требования к программе
В программе должно быть реализовано решение одной (или нескольких) из задач, перечисленных в разделе. Задача должна быть решена с помощью одного или нескольких методов организации и поиска информации. Для каждого метода существуют различные модификации, дополняющие или улучшающие возможности или характеристики метода (и усложняющие реализацию).

Основные реализованные алгоритмы необходимо покрыть тестами. Программа должна позволять выбрать любой из реализованных алгоритмов поиска и запустить его на (достаточно произвольных) исходных данных. При этом должна быть возможность как автоматической, так и ручной проверки корректности работы алгоритмов (в т.ч. должна быть возможность просмотра как исходных данных, так и результата). Программа должна обладать пользовательским интерфейсом (консольным или графическим). Пользовательский интерфейс, в особенности, графический, тестировать не требуется. Программа должна предоставлять функцию измерения времени выполнения алгоритма. Должна быть функция сравнения алгоритмов – по времени выполнения на одних и тех же входных данных.

### Выбранная задача: 
#### 2.12. Реализация виртуальной файловой системы
>Пусть имеется набор файлов, размещенных в реальной файловой системе (возможно, в одной выделенной папке, а возможно и в разных). Требуется реализовать средства, описывающие иерархическую структуру директорий. Исходные файлы привязываются к этой виртуальной, существующей лишь в оперативной памяти, структуре, без физического перемещения. Требуется оснастить такую виртуальную файловую систему (ФС) управляющей оболочкой:
>
>− создание нового файла в рамках виртуальной ФС должно происходить путем прикрепления к ней существующего файла;
>
>− удаление из виртуальной ФС не должно приводить к удалению файла из физической ФС;
>
>− перемещение и переименование файла в виртуальной ФС не должно затрагивать физический файл.
>
>В качестве дополнительной задачи – реализовать механизм управления правами доступа с использованием групповых политик и наследования. 

### Решение
( папки 
[Associative](include/Associative), 
[VFS](include/VFS), 
[script/L3_Graphs.cpp](script/L3_Graphs.cpp)
 )
1) Реализация классов `HashTable`, `HashSet` (подробнее смотреть в файле [HashTable](include/Associative/_hashtable.md)). Отличие состоит в подходе работы с коллизиями: для множества выбран метод открытой адресации с линейным зондированием, для хэш-таблицы - методы цепочек. Оба класса для хеширования используют `Hash`
2) Данные структуры данных были протестированы функционально, нагрузочно
3) Реализация классов `User`, `Group`, `FileDescriptor`:
    - классы `User`, `Group` являются набором данных о соответствующих составляющих `VFS`
    - `FileDescriptor` - основа для написания `VFS`. Он представляет метаданные о виртуальных файлах. Про его функцию как компонент `VFS` в файле: [FileDescriptor](include/VFS/_fd.md)
4) Протестировано сочетание структуры данных `HashTable` и `FileDescriptor` - вместе они дают `index_table`, используюмую в `VFS` для хранения, поиска, обращения к виртуальным файлам и директориям. Тестирование проводилось в первую очередь как нагрузочное. По содержимому файлов [filenames](test/VFS/_filename.txt), [usernames](test/VFS/_username.txt) генерировались файл-дескрипторы и заносились в `index_table` (посмотреть результат - полученный набор файлов - можно [здесь](test/_test_results/fs_indextable.txt)) Далее тестировалось обращение (поиск) полученной системы файлов по их виртуальному пути: [результаты](_test_results/search_test_indextable.txt). По этим данным с помощью библиотеки __SFML__ построен график:
>![График __SFML__](img/GR%20L3.gif)
>
>(!) Работа с графиком зависит от папки `resources`, а именно от шрифта в нем: `resources/font.ttf`

        Для написания графиков в качестве основы был взят [этот репозиторий](https://github.com/bechu/sfml-plot/tree/master)