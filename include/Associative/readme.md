## Реализация HashTable
`HashTable` состоит из массива узлов (указателей на узлы). 
___Поля___:
- `Node** _storage = nullptr`
- `std::size_t _size = 0`
- `std::size_t _buffer_size = 256`
- `float _max_load_factor = 0.25`. Классический `current_load_factor` рассчитывается по следующей формуле: `current_load_factor = (_size / _buffer_size)`. С учетом переопределения понятия _корзины_ в будущем возможно будет своя формулка.

___Шаблонные аргументы___:
- `Key`. На данный тип вешается концепт "тип, объекты которого можно проверять на равенство".
- `Value`
- `CollisionStrategy`. Данный класс предоставляет фильтр, через который производится поиск узла или места под новый узел. В случае выбора стратегии цепочек возможно появление корзин (больше 1 объекта на индекс). При выборе стратегии открытой адресации такие корзины не возникают. Однако заполнение хэш-таблицы происходит гораздо быстрее (следовательно `current_load_factor` быстро доходит до максимально допустимого и таким образом чаще вызывается перестройка хеш-таблицы). Таким образом нельзя утверждать, что какая-то из стратегии является абсолютно лучше другой. Поэтому пользователю предоставляется выбор стратегии.

Узел (внутренняя структура `Node`) хранит в себе:
- Пару ключ-значение: `tmn::Pair<const Key, Value> pair`
- Указатели: вниз (`down`) и вперед (`right`). Итерация идет вниз, если указатель `down` у очередной ноды не равен `nullptr`. Иначе вправо. 

Процесс вычисления индекса:
1) Прогнать аргумент через `Hash` 
2) Взять остаток от полученного результата при делении на `_buffer_size` 

Изначально таблица хранит в себе только массив `nullptr`. Начинается заполнение. 
1) Если выбрана _стратегия цепочек_: первый `Bucket` (больше 1 объекта на индекс) появляется, если какой-то индекс уже занят.
2) В _стратегии открытой адресации_ понятий `Bucket` просто не возникнет. 

### Аллокация объектов
Для аллокации будут использоваться:
```cpp
std::allocator<Node> _alloc_node;
```
Выбор аллокатора для хеш-таблиц не предусмотрен.

### Работа стратегий
Через соответствующий общий фильтр-класс `collision_strategy_traits`. Необходимые обязательные базовые операции стратегий, которые можно будет поместить в `collision_strategy_traits`, появятся здесь позже (может быть)

### Итерация по контейнеру 
>![StrategyChains](../../img/L3%20StrategyChains.png)
>Иллюстрация внутреннего устройства `HashTable`, построенной на _стратегии цепочек_. Все узлы между собой связаны в одну сторону, чтобы обеспечить итерацию по контейнеру. Для итерации возможна реализация простого `list`-подобного итератора. Образ итерируемого объекта будет простым односвязным списком, тип значения узлов которого будет `tmn::Pair<const Key, Value>`: ![LinkedList](../../img/L3%20LinkedList.png)
>В случае использования стратегии _открытой адресации_ образ контейнера также будет односвязным списком: ![StrategyOA](../../img/L3%20StrategyOA.png)

### Грубая оценка
Такая хэш-таблица требует памяти __O(K + V)__, где __K + V__ - множество пар _ключ+запись_. Обертки в виде: `Pair<Key, Value>`, `Node` в данном случае не учитываются (рассматриваются как достаточно легковесные обертки).

При этом временная сложность поиска остается __О(1)__ (аморт.): сначала подсчёт хэш-значения, а потом проход по бакету, __если требуется__.

На данный момент используется детерменированная хеш-функция из STL (просто функтор обернут в функцию для сомнительного удобоства).

