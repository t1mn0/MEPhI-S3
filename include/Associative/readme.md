## Реализация HashTable
`HashTable` состоит из массива узлов (указателей на узлы). 
___Поля___:
- `Node** _storage = nullptr`
- `std::size_t _size = 0`
- `std::size_t _buffer_size = 256`
- `float _max_load_factor = 0.25`. Классический `current_load_factor` рассчитывается по следующей формуле: `current_load_factor = (_size / _buffer_size)`. С учетом переопределения понятия _корзины_ в будущем возможно будет своя формулка.

___Шаблонные аргументы___:
- `Key`. На данный тип вешается концепт "тип, объекты которого можно проверять на равенство".
- `Value`
- `CollisionStrategy`. Данный класс предоставляет фильтр, через который производится поиск узла или места под новый узел. В случае выбора стратегии цепочек возможно появление корзин. При выборе стратегии открытой адресации корзины не возникают. Однако заполнение хэш-таблицы происходит гораздо быстрее (следовательно `current_load_factor` быстро доходит до максимально допустимого и таким образом чаще вызывается перестройка хеш-таблицы). Таким образом нельзя утверждать, что какая-то из стратегии является абсолютно лучше другой. Поэтому пользователю предоставляется выбор стратегии.

Узел (внутренняя структура `Node`) хранит в себе:
- Индекс (хеш-значение): `std::size_t index = 0`
- Пару ключ-значение: `tmn::Pair<const Key, Value> pair`
- <_опционально_ (пока не точно)> `bool isBucket = false`

Процесс вычисления индекса:
1) Прогнать аргумент через `Hash` 
2) Взять остаток от полученного результата при делении на `_buffer_size` 

	Изначально таблица хранит в себе только массив `nullptr`. Начинается заполнение. 
	1) Если выбрана _стратегия цепочек_: первый `Bucket` появляется, если какой-то индекс уже занят. При вставке по занятому индексу, если узел в нем еще не `isBucket = true`, то меняем это значение у уже давно вставленного узла. Иначе просто конструируем узел с флагом `isBucket = true`.
	2) В _стратегии открытой адресации_ понятий `Bucket` просто не возникнет. 

### Аллокация объектов
Для аллокации будут использоваться:
```cpp
std::allocator<tmn::Pair<const Key, Value>> _alloc_pair;
std::allocator<Node> _alloc_node;
```
Выбор аллокатора для хеш-таблиц не предусмотрен.

### Работа стратегий
Через соответствующий общий фильтр-класс `collision_strategy_traits`. Необходимые обязательные базовые операции стратегий, которые можно будет поместить в `collision_strategy_traits`, появятся здесб позже.

### Итерация по контейнеру
>![StrategyChains](../../img/L3%20StrategyChains.png)
>Иллюстрация внутреннего устройства `HashTable`, построенной на _стратегии цепочек_. Все узлы между собой связаны в обе стороны, чтобы обеспечить итерацию по контейнеру. Для итерации возможна реализация простого `list` итератора. Образ итерируемого объекта будет простым двусвязным списком, тип значения узлов которого будет `tmn::Pair<const Key, Value>`: ![DoubleLinkedList](../../img/L3%20DoubleLinkedList.png)
>В случае использования стратегии _открытой адресации_ образ контейнера также будет двусвязными списком:
>![StrategyOA](../../img/L3%20StrategyOA.png)

### Грубая оценка
Такая хэш-таблица требует памяти __O(K + V)__, где __K + V__ - множество пар _ключ+запись_. Обертки в виде: `Pair<Key, Value>`, `Node` в данном случае не учитываются (рассматриваются как достаточно легковесные обертки).

При этом временная сложность поиска остается __О(1)__ (аморт.): сначала подсчёт хэш-значения, а потом проход по бакету, __если требуется__.

На данный момент используется детерменированная хеш-функция из STL (просто функтор обернут в функцию для сомнительного удобоства).

